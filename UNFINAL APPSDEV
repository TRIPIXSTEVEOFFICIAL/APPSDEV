import tkinter as tk
from time import timezone

import customtkinter as ctk
import json
import os
import time
import threading
import calendar
import webbrowser
from datetime import datetime, timedelta
from tkinter import ttk, messagebox
from tkinter import filedialog
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from datetime import datetime

# Set appearance and theme
ctk.set_appearance_mode("System")
ctk.set_default_color_theme("blue")

current_user = None

# SHOWS THE MAIN SCREEN LOGIN/REGISTER
def show_login():
    # Create login window with improved design
    login_win = ctk.CTk()
    login_win.geometry("750x700")
    login_win.title("Habit Tracker - Login/Register Screen")

    bg_frame = ctk.CTkFrame(login_win, fg_color=("#DCF2FF", "#1A374D"))
    bg_frame.place(relx=0, rely=0, relwidth=1, relheight=1)

    header_frame = ctk.CTkFrame(bg_frame, fg_color="transparent")
    header_frame.pack(pady=(40, 20), padx=20, fill="x")

    logo_label = ctk.CTkLabel(header_frame, text="Habit Tracker App",
                              font=("Roboto", 32, "bold"),
                              text_color=("#1A374D", "#FFFFFF"))
    logo_label.pack()

    tagline = ctk.CTkLabel(header_frame, text="Track your habits one step at a time. \nBest of luck!",
                           font=("Roboto", 14),
                           text_color=("#3F72AF", "#B1D0E0"))
    tagline.pack(pady=5)

    # Create main form container
    form_frame = ctk.CTkFrame(bg_frame, fg_color=("#FFFFFF", "#203647"), corner_radius=15)
    form_frame.pack(pady=20, padx=40, fill="both", expand=True)

    # Login form
    ctk.CTkLabel(form_frame, text="Ready for your grind? Register now! \nAfter being registered feel free to login!", font=("Roboto", 20, "bold")).pack(pady=(20, 15))

    ctk.CTkLabel(form_frame, text="Username:", anchor="w").pack(pady=(10, 0), padx=20, anchor="w")
    user_entry = ctk.CTkEntry(form_frame, height=35, placeholder_text="Enter your username here.")
    user_entry.pack(pady=(5, 10), padx=20, fill="x")

    ctk.CTkLabel(form_frame, text="Password:", anchor="w").pack(pady=(10, 0), padx=20, anchor="w")
    pass_entry = ctk.CTkEntry(form_frame, height=35, placeholder_text="Enter your password here.", show="•")
    pass_entry.pack(pady=(5, 15), padx=20, fill="x")

    # Status label for error messages
    status_label = ctk.CTkLabel(form_frame, text="", text_color=("#FF5252", "#FF6B6B"))
    status_label.pack(pady=5)

    # Buttons frame
    button_frame = ctk.CTkFrame(form_frame, fg_color="transparent")
    button_frame.pack(pady=15, fill="x")

    def login():
        username = user_entry.get()
        password = pass_entry.get()
        if not username or not password:
            status_label.configure(text="Please fill in all fields")
            return

        if os.path.exists(f"{username}.json"):
            with open(f"{username}.json", "r") as f:
                data = json.load(f)
                if data["password"] == password:
                    global current_user
                    current_user = username
                    login_win.after(100, lambda: [login_win.destroy(), show_tracker()])
                else:
                    status_label.configure(text="Wrong password, type it again")
        else:
            status_label.configure(text="User does not exist, please register first.")

    def register():
        username = user_entry.get()
        password = pass_entry.get()

        if not username or not password:
            status_label.configure(text="Please fill in all fields")
            return

        if len(password) < 6:
            status_label.configure(text="Password must be at least 6 characters, can be randomized")
            return

        if not os.path.exists(f"{username}.json"):
            with open(f"{username}.json", "w") as f:
                json.dump({"password": password, "habits": {}, "history": []}, f)
            status_label.configure(text="Registration successful! You can now login.")
        else:
            status_label.configure(text="User already exists. ")

    # Login button
    login_btn = ctk.CTkButton(button_frame, text="LOGIN",
                              font=("Roboto", 15, "bold"),
                              height=40,
                              corner_radius=8,
                              command=login,
                              fg_color=("#3F72AF", "#6998AB"))
    login_btn.pack(pady=5, padx=20, fill="x")

    # Register button
    register_btn = ctk.CTkButton(button_frame, text="REGISTER",
                                 font=("Roboto", 15),
                                 height=40,
                                 corner_radius=8,
                                 command=register,
                                 fg_color=("#B1D0E0", "#203647"),
                                 text_color=("#1A374D", "#FFFFFF"),
                                 hover_color=("#90C2E7", "#264653"))
    register_btn.pack(pady=(5, 15), padx=20, fill="x")

    # Footer
    footer_text = ctk.CTkLabel(bg_frame, text="© 2025-2026 Habit Master",
                               font=("Roboto", 12),
                               text_color=("#6998AB", "#B1D0E0"))
    footer_text.pack(pady=10)

    login_win.mainloop()


def show_tracker():
    app = ctk.CTk()
    app.geometry("950x700")
    app.title("Habit Tracker App - Main Screen")

    # Set up data
    user_file = f"{current_user}.json"
    with open(user_file, "r") as f:
        data = json.load(f)
        habit_data = data.get("habits", {})
        habit_history = data.get("history", [])

    def save_habits():
        with open(user_file, "w") as f:
            json.dump({"password": data["password"], "habits": habit_data, "history": habit_history}, f)

    # Create a modern dashboard layout
    main_frame = ctk.CTkFrame(app, fg_color=("gray95", "gray10"))
    main_frame.pack(fill="both", expand=True)

    # Left sidebar for user info and navigation
    sidebar = ctk.CTkFrame(main_frame, width=200, corner_radius=0, fg_color=("#3F72AF", "#1A374D"))
    sidebar.pack(side="left", fill="y", padx=0, pady=0)
    sidebar.pack_propagate(False)

    # App logo in sidebar
    logo_frame = ctk.CTkFrame(sidebar, fg_color="transparent", height=100)
    logo_frame.pack(fill="x", pady=(20, 20))

    logo_text = ctk.CTkLabel(logo_frame, text="Add your habits.\n Set schedules.\n View your history",
                             font=("Roboto", 20, "bold"),
                             text_color="#FFFFFF")
    logo_text.pack(pady=10)

    # User info
    user_frame = ctk.CTkFrame(sidebar, fg_color=("gray80", "gray20"), corner_radius=10)
    user_frame.pack(padx=15, pady=10, fill="x")

    welcome_text = ctk.CTkLabel(user_frame,
                                text=f"Welcome,\n{current_user}!",
                                font=("Roboto", 16, "bold"),
                                text_color=("#1A374D", "#B1D0E0"))
    welcome_text.pack(pady=10)

    date_label = ctk.CTkLabel(user_frame,
                              text=datetime.now().strftime("%B %d, %Y %H:%M"),
                              font=("Roboto", 12),
                              text_color=("#3F72AF", "#B1D0E0"))
    date_label.pack(pady=(0, 10))

    # Navigation buttons
    nav_frame = ctk.CTkFrame(sidebar, fg_color="transparent")
    nav_frame.pack(pady=20, fill="x")

    def show_history():
        top = ctk.CTkToplevel(app)
        top.title("Habit History")
        top.geometry("650x550")
        top.focus_set()

        history_frame = ctk.CTkFrame(top)
        history_frame.pack(fill="both", expand=True, padx=20, pady=20)

        ctk.CTkLabel(history_frame, text="Completed Habit History",
                     font=("Roboto", 24, "bold")).pack(pady=(10, 20))

        hist_box = ctk.CTkTextbox(history_frame, width=550, height=380, font=("Roboto", 12))
        hist_box.pack(pady=10, padx=10, fill="both", expand=True)

        if not habit_history:
            hist_box.insert("end", "No history yet. Complete some habits to see them here!")
        else:
            for record in reversed(habit_history):
                hist_box.insert("end", f"➤ {record['time']} - {record['habit']} marked as {record['status']}\n\n")

        # Print button
        def print_history():
            filename = f"{current_user}_habit_history.html"
            with open(filename, "w") as f:
                f.write(f"""<!DOCTYPE html>
                <html>
                <head>
                    <title>Habit History - {current_user}</title>
                    <style>
                        body {{ font-family: Arial, sans-serif; margin: 40px; }}
                        h1 {{ color: #3F72AF; }}
                        .record {{ margin-bottom: 10px; padding: 10px; border-bottom: 1px solid #eee; }}
                        .date {{ color: #666; }}
                        @media print {{
                            .no-print {{ display: none; }}
                            body {{ margin: 0.5cm; }}
                        }}
                    </style>
                </head>
                <body>
                    <h1>Habit History record for {current_user}</h1>
                    <p>Generated on {datetime.now().strftime("%B %d, %Y at %H:%M")}</p>
                    <hr>
                    <div class="no-print">
                        <button onclick="window.print()">Print this page</button>
                        <p>Click the button above to print or save as PDF</p>
                    </div>
                    <hr>
                """)

                if not habit_history:
                    f.write("<p>No habit history recorded yet.</p>")
                else:
                    for record in reversed(habit_history):
                        f.write(f"""
                        <div class="record">
                            <span class="date">{record['time']}</span> - 
                            <strong>{record['habit']}</strong> marked as {record['status']}
                        </div>
                        """)

                f.write("""
                    <hr>
                    <p>Habit Master - Track your habits and improve your life</p>
                </body>
                </html>
                """)

            webbrowser.open(filename)

        buttons_frame = ctk.CTkFrame(history_frame, fg_color="transparent")
        buttons_frame.pack(pady=15, fill="x")

        ctk.CTkButton(buttons_frame, text="Close",
                      font=("Roboto", 14),
                      height=35,
                      command=top.destroy).pack(side="left", padx=10, expand=True, fill="x")

    def show_scheduler():
        # Create scheduler window
        scheduler_win = ctk.CTkToplevel(app)
        scheduler_win.title("Habit Scheduler - Main Screen")
        scheduler_win.geometry("1000x1000")
        scheduler_win.focus_set()

        # Add scheduler to data if it doesn't exist
        if "scheduler" not in data:
            data["scheduler"] = {}
            save_habits()

        # Get current date
        today = datetime.now()
        current_year = today.year
        current_month = today.month

        # Create frame for scheduler
        main_frame = ctk.CTkFrame(scheduler_win)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # Calendar header
        header_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        header_frame.pack(fill="x", pady=(0, 10))

        ctk.CTkLabel(header_frame, text="Habit Scheduler",
                     font=("Roboto", 24, "bold")).pack(side="left")

        # Month navigation
        month_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        month_frame.pack(side="right")

        month_label = ctk.CTkLabel(month_frame, text=f"{calendar.month_name[current_month]} {current_year}",
                                   font=("Roboto", 16))
        month_label.pack(side="left", padx=10)

        # Calendar container
        calendar_frame = ctk.CTkFrame(main_frame)
        calendar_frame.pack(fill="both", expand=True, pady=10)

        # Controls frame
        controls_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        controls_frame.pack(fill="x", pady=10)

        # Habit selection
        habit_frame = ctk.CTkFrame(controls_frame)
        habit_frame.pack(side="left", fill="both", expand=True, padx=(0, 10))

        ctk.CTkLabel(habit_frame, text="Select Habit:",
                     font=("Roboto", 14)).pack(pady=(10, 5), padx=10, anchor="w")

        scheduler_habit = ctk.CTkComboBox(habit_frame, values=list(habit_data.keys()) or ["No habits"],
                                          height=35, width=200)
        scheduler_habit.pack(pady=5, padx=10, fill="x")

        # Date selection
        date_frame = ctk.CTkFrame(controls_frame)
        date_frame.pack(side="left", fill="both", expand=True, padx=10)

        ctk.CTkLabel(date_frame, text="Set Date:",
                     font=("Roboto", 14)).pack(pady=(10, 5), padx=10, anchor="w")

        date_entry = ctk.CTkEntry(date_frame, placeholder_text="YYYY-MM-DD")
        date_entry.pack(pady=5, padx=10, fill="x")

        # Time selection
        time_frame = ctk.CTkFrame(controls_frame)
        time_frame.pack(side="left", fill="both", expand=True, padx=(10, 0))

        ctk.CTkLabel(time_frame, text="Set Time:",
                     font=("Roboto", 14)).pack(pady=(10, 5), padx=10, anchor="w")

        time_entry = ctk.CTkEntry(time_frame, placeholder_text="HH:MM")
        time_entry.pack(pady=5, padx=10, fill="x")

        # Schedule button
        def schedule_habit():
            habit_name = scheduler_habit.get()
            date_str = date_entry.get()
            time_str = time_entry.get()

            # Validate inputs
            if not habit_name or habit_name == "No habits":
                messagebox.showerror("Error", "Please select a habit")
                return

            try:
                # Validate date format
                datetime.strptime(date_str, "%Y-%m-%d")
            except ValueError:
                messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD")
                return

            # Validate time format
            try:
                datetime.strptime(time_str, "%H:%M")
            except ValueError:
                messagebox.showerror("Error", "Invalid time format. Use HH:MM")
                return

            # Add to scheduler
            if "scheduler" not in data:
                data["scheduler"] = {}

            # Initialize habit list if not exists
            if habit_name not in data["scheduler"]:
                data["scheduler"][habit_name] = []

            # Add new schedule
            data["scheduler"][habit_name].append({
                "date": [date_str],
                "time": time_str
            })

            # Save habits
            save_habits()

            # Update calendar and scheduled list
            update_calendar(current_year, current_month)
            display_scheduled_for_date(date_str)

            # Clear entries
            date_entry.delete(0, "end")
            time_entry.delete(0, "end")

        # Schedule button
        schedule_btn = ctk.CTkButton(main_frame, text="Schedule Habit", command=schedule_habit)
        schedule_btn.pack(pady=10)

        # Buttons frame
        buttons_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        buttons_frame.pack(fill="x", pady=10)

        # Calendar days
        days_frame = ctk.CTkFrame(calendar_frame)
        days_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Calendar cells
        calendar_cells = []
        scheduled_days = {}

        def update_calendar(year, month):
            # Clear previous calendar cells
            for widget in days_frame.winfo_children():
                widget.destroy()

            # Get calendar info for current month
            cal = calendar.monthcalendar(year, month)

            # Create headers for days of week
            days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
            for i, day in enumerate(days):
                header = ctk.CTkLabel(days_frame, text=day, font=("Roboto", 12, "bold"))
                header.grid(row=0, column=i, sticky="nsew", padx=2, pady=2)

            # Clear previous references
            calendar_cells.clear()
            scheduled_days.clear()

            # Get scheduled dates
            scheduled = data.get("scheduler", {})

            # Create cells for each day in month
            for week_idx, week in enumerate(cal):
                for day_idx, day in enumerate(week):
                    if day == 0:
                        # Empty cell for days not in current month
                        cell = ctk.CTkFrame(days_frame, fg_color="transparent")
                        cell.grid(row=week_idx + 1, column=day_idx, sticky="nsew", padx=2, pady=2)
                        continue

                    # Create cell frame
                    cell = ctk.CTkFrame(days_frame, corner_radius=5)
                    cell.grid(row=week_idx + 1, column=day_idx, sticky="nsew", padx=2, pady=2)

                    # Format date string
                    date_str = f"{year}-{month:02d}-{day:02d}"

                    # Check if date is today
                    is_today = (year == today.year and month == today.month and day == today.day)

                    # Create day label
                    day_label = ctk.CTkLabel(cell, text=str(day),
                                             font=("Roboto", 12, "bold" if is_today else "normal"),
                                             text_color="#FF5722" if is_today else None)
                    day_label.pack(pady=(5, 0))

                    # Create container for habit indicators
                    habits_container = ctk.CTkFrame(cell, fg_color="transparent", height=30)
                    habits_container.pack(fill="both", expand=True, padx=2)

                    # Add scheduled habits for this day
                    scheduled_for_day = []
                    for habit_id, schedules in scheduled.items():
                        for schedule in schedules:
                            if date_str in schedule["date"]:
                                scheduled_for_day.append({
                                    "habit": habit_id,
                                    "time": schedule["time"]
                                })

                    # Show indicator for scheduled habits
                    if scheduled_for_day:
                        for i, item in enumerate(scheduled_for_day[:2]):  # Show max 2 habits
                            habit_indicator = ctk.CTkLabel(habits_container,
                                                           text="• " + item["habit"][:10],
                                                           font=("Roboto", 9),
                                                           text_color="#3F72AF")
                            habit_indicator.pack(anchor="w", padx=2)

                        if len(scheduled_for_day) > 2:
                            more_label = ctk.CTkLabel(habits_container,
                                                      text=f"+{len(scheduled_for_day) - 2} more",
                                                      font=("Roboto", 9),
                                                      text_color="#666")
                            more_label.pack(anchor="w", padx=2)

                    # Store cell reference and scheduled habits
                    calendar_cells.append(cell)
                    scheduled_days[date_str] = scheduled_for_day

                    # Bind click event to select date
                    cell.bind("<Button-1>", lambda e, d=date_str: select_date(d))

            # Update month label
            month_label.configure(text=f"{calendar.month_name[month]} {year}")

            # Make grid cells expand
            for i in range(7):
                days_frame.grid_columnconfigure(i, weight=1)
            for i in range(7):
                days_frame.grid_rowconfigure(i, weight=1)

        # Navigate to previous month
        def prev_month():
            nonlocal current_year, current_month
            if current_month == 1:
                current_month = 12
                current_year -= 1
            else:
                current_month -= 1
            update_calendar(current_year, current_month)

        # Navigate to next month
        def next_month():
            nonlocal current_year, current_month
            if current_month == 12:
                current_month = 1
                current_year += 1
            else:
                current_month += 1
            update_calendar(current_year, current_month)

        # Select date
        def select_date(date_str):
            date_entry.delete(0, "end")
            date_entry.insert(0, date_str)

            # Show scheduled habits for this date
            display_scheduled_for_date(date_str)

        # Display scheduled habits for selected date
        def display_scheduled_for_date(date_str):
            # Clear previous entries
            for widget in scheduled_list.winfo_children():
                widget.destroy()

            # Get scheduled habits for date
            scheduled_for_day = []
            for habit_name, schedules in data.get("scheduler", {}).items():
                for schedule in schedules:
                    if date_str in schedule["date"]:
                        scheduled_for_day.append({
                            "habit": habit_name,
                            "time": schedule["time"]
                        })

            if not scheduled_for_day:
                empty_label = ctk.CTkLabel(scheduled_list, text="No habits scheduled for this date")
                empty_label.pack(pady=10)
                return

            # Add each scheduled habit
            for item in scheduled_for_day:
                habit_item = ctk.CTkFrame(scheduled_list)
                habit_item.pack(fill="x", pady=2, padx=5)

                habit_label = ctk.CTkLabel(habit_item, text=f"{item['habit']} at {item['time']}")
                habit_label.pack(side="left", padx=5, pady=5)

                # Delete button
                def delete_scheduled(habit_name=item['habit'], date=date_str, time=item['time']):
                    # Remove from data
                    schedules = data["scheduler"][habit_name]
                    for i, schedule in enumerate(schedules):
                        if date in schedule["date"] and time == schedule["time"]:
                            schedules.pop(i)
                            break

                    # If no more schedules for this habit, remove the habit key
                    if not schedules:
                        del data["scheduler"][habit_name]

                    save_habits()
                    update_calendar(current_year, current_month)
                    display_scheduled_for_date(date_str)

                delete_btn = ctk.CTkButton(habit_item, text="Delete", width=60, height=25,
                                           font=("Roboto", 10),
                                           fg_color="#F44336",
                                           command=lambda h=item['habit'], d=date_str, t=item['time']:
                                           delete_scheduled(h, d, t))
                delete_btn.pack(side="right", padx=5)

        # Add navigation buttons
        prev_btn = ctk.CTkButton(month_frame, text="<", width=30, command=prev_month)
        prev_btn.pack(side="left")

        next_btn = ctk.CTkButton(month_frame, text=">", width=30, command=next_month)
        next_btn.pack(side="right")

        # Add scheduled habits list
        scheduled_list_frame = ctk.CTkFrame(main_frame)
        scheduled_list_frame.pack(fill="x", pady=10)

        ctk.CTkLabel(scheduled_list_frame, text="Scheduled Habits:",
                     font=("Roboto", 14, "bold")).pack(anchor="w", padx=5, pady=5)

        scheduled_list = ctk.CTkScrollableFrame(scheduled_list_frame, height=55)
        scheduled_list.pack(fill="x", padx=5, pady=5)

        # Initialize calendar
        update_calendar(current_year, current_month)

        def add_scheduled():
            habit_name = scheduler_habit.get()
            date_val = date_entry.get().strip()
            time_val = time_entry.get().strip()

            # Validate inputs
            if habit_name not in habit_data or habit_name == "No habits":
                status_label.configure(text="Please select a valid habit", text_color="#F44336")
                return

            # Validate date format with multiple parsing attempts
            parsed_date = None
            date_formats = [
                "%m-%d-%Y",  # MM-DD-YYYY
                "%m/%d/%Y",  # MM/DD/YYYY
                "%Y-%m-%d",  # YYYY-MM-DD
                "%Y/%m/%d",  # YYYY/MM/DD
                "%d-%m-%Y",  # DD-MM-YYYY
                "%d/%m/%Y"  # DD/MM/YYYY
            ]

            for date_format in date_formats:
                try:
                    parsed_date = datetime.strptime(date_val, date_format)
                    break
                except ValueError:
                    continue

            if parsed_date is None:
                status_label.configure(
                    text="Invalid date format. Use formats like MM-DD-YYYY, MM/DD/YYYY, etc.",
                    text_color="#F44336"
                )
                return

            # Normalize date to YYYY-MM-DD format for consistency
            normalized_date = parsed_date.strftime("%Y-%m-%d")

            # Validate time format
            try:
                # Allow both 24-hour and 12-hour time formats
                time_formats = ["%H:%M", "%I:%M %p", "%I:%M%p"]
                parsed_time = None
                for time_format in time_formats:
                    try:
                        parsed_time = datetime.strptime(time_val, time_format)
                        break
                    except ValueError:
                        continue

                if parsed_time is None:
                    raise ValueError("Invalid time format")

                # Normalize time to 24-hour format
                normalized_time = parsed_time.strftime("%H:%M")
            except ValueError:
                status_label.configure(
                    text="Invalid time format. Use HH:MM or 12-hour format like 09:30 AM",
                    text_color="#F44336"
                )
                return

            # Initialize scheduler data if needed
            if "scheduler" not in data:
                data["scheduler"] = {}

            # Add habit to scheduler
            if habit_name not in data["scheduler"]:
                data["scheduler"][habit_name] = []

            # Check if already scheduled
            for schedule in data["scheduler"][habit_name]:
                if normalized_date in schedule["date"] and normalized_time == schedule["time"]:
                    status_label.configure(text="This habit is already scheduled at this time", text_color="#F44336")
                    return

            # Add new schedule
            data["scheduler"][habit_name].append({
                "date": normalized_date,
                "time": normalized_time
            })

            save_habits()
            update_calendar(current_year, current_month)

            # Clear entries
            date_entry.delete(0, "end")
            time_entry.delete(0, "end")

            # Show confirmation
            status_label.configure(text=f"Scheduled {habit_name} for {normalized_date} at {normalized_time}",
                                   text_color="#4CAF50")

            # Update displayed scheduled habits if date is selected
            if normalized_date:
                display_scheduled_for_date(normalized_date)

        def check_habit_reminders():
            """
            Check for scheduled habits that are due soon and send notifications
            """
            current_time = datetime.now()
            current_date = current_time.strftime("%Y-%m-%d")
            current_hour_minute = current_time.strftime("%H:%M")

            # Check for habits scheduled for today
            reminders = []
            for habit_name, schedules in data.get("scheduler", {}).items():
                for schedule in schedules:
                    # Check if the habit is scheduled for today
                    if schedule["date"] == current_date:
                        # Check time - give a 5-minute window before and after the scheduled time
                        scheduled_time = datetime.strptime(schedule["time"], "%H:%M")
                        scheduled_time_minus_5 = (datetime.combine(datetime.today(), scheduled_time.time()) - timedelta(
                            minutes=5)).time()
                        scheduled_time_plus_5 = (datetime.combine(datetime.today(), scheduled_time.time()) + timedelta(
                            minutes=5)).time()

                        current_time_obj = datetime.strptime(current_hour_minute, "%H:%M").time()

                        if scheduled_time_minus_5 <= current_time_obj <= scheduled_time_plus_5:
                            reminders.append({
                                "habit": habit_name,
                                "time": schedule["time"]
                            })

            # Display reminders
            if reminders:
                # Create reminder window
                reminder_win = ctk.CTkToplevel(app)
                reminder_win.title("Habit Reminders")
                reminder_win.geometry("400x300")
                reminder_win.focus_set()

                # Title
                ctk.CTkLabel(reminder_win, text="Upcoming Habits",
                             font=("Roboto", 20, "bold")).pack(pady=(20, 10))

                # Reminder details
                for reminder in reminders:
                    reminder_frame = ctk.CTkFrame(reminder_win)
                    reminder_frame.pack(fill="x", padx=20, pady=5)

                    ctk.CTkLabel(reminder_frame,
                                 text=f"{reminder['habit']} is scheduled for {reminder['time']}",
                                 font=("Roboto", 14)).pack(side="left", padx=10)

                # Close button
                close_btn = ctk.CTkButton(reminder_win, text="Close", command=reminder_win.destroy)
                close_btn.pack(pady=20)

                # Optional: Play a sound or make a system notification
                # You can add platform-specific notification logic here
                # For now, we'll just create a visual popup

        # Add this to your main application setup or scheduler initialization
        def start_reminder_check():
            """
            Start periodic check for habit reminders
            """
            check_habit_reminders()
            # Schedule the next check - adjust interval as needed
            app.after(300000, start_reminder_check)  # Check every 5 minutes (300000 milliseconds)

        # Call this when your application starts
        start_reminder_check()

        # Create print button
        def print_schedule():
            filename_base = f"{current_user}_schedule"
            pdf_filename = f"{filename_base}.pdf"
            html_filename = f"{filename_base}.html"

            # Get all scheduled habits
            all_scheduled = []
            for habit_name, schedules in data.get("scheduler", {}).items():
                for schedule in schedules:
                    all_scheduled.append({
                        "habit": habit_name,
                        "date": schedule["date"],
                        "time": schedule["time"]
                    })

            # Sort by date and time
            all_scheduled.sort(key=lambda x: (x["date"], x["time"]))

            # Group schedules by date for highlighting
            date_with_schedules = set()
            for schedule in all_scheduled:
                date_with_schedules.add(schedule['date'])

            with open(html_filename, "w") as f:
                f.write(f"""<!DOCTYPE html>
                <html>
                <head>
                    <title>Habit Schedule - {current_user}</title>
                    <style>
                        body {{ font-family: Arial, sans-serif; margin: 40px; }}
                        h1 {{ color: #3F72AF; }}
                        h2 {{ color: #3F72AF; margin-top: 30px; }}
                        table {{ border-collapse: collapse; width: 100%; margin-top: 20px; }}
                        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                        th {{ background-color: #f2f2f2; }}
                        .habit-cell {{ font-weight: bold; }}
                        .date-highlight {{ background-color: #ffffcc; }}
                        .calendar {{ margin-top: 30px; border-collapse: collapse; width: 100%; }}
                        .calendar th {{ background-color: #3F72AF; color: white; }}
                        .calendar td {{ text-align: center; height: 30px; width: 14%; }}
                        .calendar .scheduled {{ background-color: #ffffcc; font-weight: bold; }}
                        @media print {{
                            .no-print {{ display: none; }}
                            body {{ margin: 0.5cm; }}
                        }}
                    </style>
                </head>
                <body>
                    <h1>Habit Schedule for {current_user}</h1>
                    <p>Generated on {datetime.now().strftime("%B %d, %Y at %H:%M")}</p>
                    <div class="no-print">
                        <button onclick="window.print()">Print/Save as PDF</button>
                        <button onclick="generatePDF()">Download as PDF</button>
                        <p>Click the first button to print or save as PDF using your browser's print dialog</p>
                    </div>
                    <hr>
                """)

                if not all_scheduled:
                    f.write("<p>No habits scheduled yet.</p>")
                else:
                    f.write("""
                    <h2>Scheduled Habits</h2>
                    <table>
                        <tr>
                            <th>Date</th>
                            <th>Time</th>
                            <th>Habit</th>
                        </tr>
                    """)

                    for schedule in all_scheduled:
                        highlight_class = "date-highlight" if schedule['date'] in date_with_schedules else ""
                        f.write(f"""
                        <tr class="{highlight_class}">
                            <td>{schedule['date']}</td>
                            <td>{schedule['time']}</td>
                            <td class="habit-cell">{schedule['habit']}</td>
                        </tr>
                        """)

                    f.write("</table>")

                    # Add a section showing all scheduled habits at the bottom
                    f.write("""
                    <h2>SET SCHEDULED</h2>
                    <table>
                        <tr>
                            <th>Habit</th>
                            <th>Number of Occurrences</th>
                        </tr>
                    """)

                    # Count occurrences per habit
                    habit_counts = {}
                    for schedule in all_scheduled:
                        habit_name = schedule['habit']
                        if habit_name in habit_counts:
                            habit_counts[habit_name] += 1
                        else:
                            habit_counts[habit_name] = 1

                    for habit_name, count in habit_counts.items():
                        f.write(f"""
                        <tr>
                            <td class="habit-cell">{habit_name}</td>
                            <td>{count}</td>
                        </tr>
                        """)

                    f.write("</table>")

                f.write("""
                    <hr>
                    <p>Habit Master - Track your habits and improve your life</p>

                    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
                    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
                    <script>
                        function generatePDF() {
                            const { jsPDF } = window.jspdf;

                            // Hide the buttons during PDF generation
                            const buttons = document.querySelector('.no-print');
                            buttons.style.display = 'none';

                            const doc = new jsPDF('p', 'mm', 'a4');

                            html2canvas(document.body).then(canvas => {
                                const imgData = canvas.toDataURL('image/png');
                                const imgProps = doc.getImageProperties(imgData);
                                const pdfWidth = doc.internal.pageSize.getWidth();
                                const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;

                                doc.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
                                doc.save('""" + pdf_filename + """');

                                // Show the buttons again
                                buttons.style.display = 'block';
                            });
                        }
                    </script>
                </body>
                </html>
                """)

            # Open in web browser
            webbrowser.open(html_filename)

            # Also create a direct PDF using Python
            try:
                import pdfkit
                pdfkit.from_file(html_filename, pdf_filename)
                print(f"PDF saved as {pdf_filename}")
            except ImportError:
                print("pdfkit not installed. PDF was not generated directly.")
                print("You can still use the browser's print function to save as PDF.")

        def update_calendar(year, month):
            # Clear existing calendar items
            for widget in calendar_frame.winfo_children():
                widget.destroy()

            # Get first day of month and number of days
            first_day = datetime(year, month, 1)
            last_day = calendar.monthrange(year, month)[1]

            # Get scheduled dates for highlighting
            scheduled_dates = set()
            for habit_name, schedules in data.get("scheduler", {}).items():
                for schedule in schedules:
                    date_parts = schedule["date"].split("/")
                    if len(date_parts) == 3:
                        schedule_day, schedule_month, schedule_year = map(int, date_parts)
                        if schedule_month == month and schedule_year == year:
                            scheduled_dates.add(schedule_day)

            # Create calendar header
            month_name = calendar.month_name[month]
            header_frame = ctk.CTkFrame(calendar_frame, fg_color="transparent")
            header_frame.pack(fill="x", pady=(0, 10))

            # Use lambda with default arguments to capture current year and month
            prev_btn = ctk.CTkButton(header_frame, text="<", width=40, height=40,
                                     command=lambda y=year, m=month: navigate_month(y, m, -1))
            prev_btn.pack(side="left", padx=(0, 10))

            header_label = ctk.CTkLabel(header_frame, text=f"{month_name} {year}",
                                        font=("Roboto", 20, "bold"))
            header_label.pack(side="left", expand=True)

            next_btn = ctk.CTkButton(header_frame, text=">", width=40, height=40,
                                     command=lambda y=year, m=month: navigate_month(y, m, 1))
            next_btn.pack(side="right", padx=(10, 0))

            # Create day labels frame
            days_frame = ctk.CTkFrame(calendar_frame, fg_color="transparent")
            days_frame.pack(fill="x")

            # Day names with more flexible configuration
            day_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
            for day_idx, day_name in enumerate(day_names):
                day_label = ctk.CTkLabel(days_frame, text=day_name,
                                         font=("Roboto", 14, "bold"))
                day_label.pack(side="left", expand=True, fill="x")

            # Create calendar grid
            dates_frame = ctk.CTkFrame(calendar_frame, fg_color="transparent")
            dates_frame.pack(fill="both", expand=True)

            # Configure grid to be expandable
            for i in range(6):  # 6 rows to accommodate all possible month layouts
                dates_frame.grid_rowconfigure(i, weight=1)
            for j in range(7):  # 7 columns for days of the week
                dates_frame.grid_columnconfigure(j, weight=1)

            # Calculate first day position (Monday=0, Sunday=6)
            first_weekday = first_day.weekday()  # Monday is 0

            # Initialize position
            day = 1
            row = 0

            while day <= last_day:
                for col in range(7):
                    if (row == 0 and col < first_weekday) or day > last_day:
                        # Empty cell
                        empty_label = ctk.CTkLabel(dates_frame, text="",
                                                   fg_color="transparent")
                        empty_label.grid(row=row, column=col, sticky="nsew", padx=2, pady=2)
                    else:
                        # Day cell
                        is_scheduled = day in scheduled_dates
                        fg_color = "#ffffcc" if is_scheduled else "transparent"
                        text_color = "#000000"  # Black text

                        day_btn = ctk.CTkButton(
                            dates_frame,
                            text=str(day),
                            fg_color=fg_color,
                            text_color=text_color,
                            hover_color="#e6e6e6",
                            corner_radius=10,
                            command=lambda d=day: select_date(d)
                        )
                        day_btn.grid(row=row, column=col, sticky="nsew", padx=2, pady=2)
                        day += 1
                row += 1

        def navigate_month(current_year, current_month, direction):
            # Calculate new month and year
            new_month = current_month + direction
            new_year = current_year

            # Handle year change
            if new_month < 1:
                new_month = 12
                new_year -= 1
            elif new_month > 12:
                new_month = 1
                new_year += 1

            # Update calendar view
            update_calendar(new_year, new_month)

        def select_date(day):
            selected_date = f"{day:02d}/{current_month:02d}/{current_year}"
            date_entry.delete(1, "end")
            date_entry.insert(1, selected_date)

        # Add buttons
        add_btn = ctk.CTkButton(buttons_frame, text="Schedule Habit",
                                height=35,
                                command=add_scheduled)
        add_btn.pack(side="left", padx=5, expand=True, fill="x")

        close_btn = ctk.CTkButton(buttons_frame, text="Close",
                                  height=35,
                                  command=scheduler_win.destroy)
        close_btn.pack(side="left", padx=5, expand=True, fill="x")

        # Status label
        status_label = ctk.CTkLabel(main_frame, text="", font=("Roboto", 12))
        status_label.pack(pady=10)

        # Initialize calendar view
        update_calendar(current_year, current_month)
    def logout():
        app.destroy()
        show_login()

    # Updated navigation buttons
    nav_buttons = [
        {"text": "Dashboard", "icon": "🏠", "state": "disabled"},
        {"text": "Scheduler", "icon": "📅", "command": show_scheduler},
        {"text": "History", "icon": "📊", "command": show_history},
        {"text": "Logout", "icon": "🚪", "command": logout}
    ]

    for btn in nav_buttons:
        button = ctk.CTkButton(nav_frame,
                               text=f"{btn['icon']} {btn['text']}",
                               anchor="w",
                               font=("Roboto", 14),
                               height=40,
                               fg_color="transparent",
                               text_color=("#FFFFFF", "#FFFFFF"),
                               hover_color=("gray70", "gray30"),
                               command=btn.get('command', None),
                               state=btn.get('state', 'normal'))
        button.pack(pady=5, padx=15, fill="x")

    # Content area
    content_frame = ctk.CTkFrame(main_frame, fg_color=("gray90", "gray15"))
    content_frame.pack(side="right", fill="both", expand=True)

    # Header
    header = ctk.CTkFrame(content_frame, height=60, fg_color=("white", "gray17"), corner_radius=0)
    header.pack(fill="x", pady=0)

    ctk.CTkLabel(header, text=f"{current_user}'s Dashboard",
                 font=("Roboto", 24, "bold")).pack(side="left", padx=20, pady=15)

    # Main content area with two columns
    dashboard = ctk.CTkFrame(content_frame, fg_color="transparent")
    dashboard.pack(padx=20, pady=20, fill="both", expand=True)

    # Left column - Habit list
    habits_container = ctk.CTkFrame(dashboard, fg_color="transparent")
    habits_container.pack(side="left", fill="both", expand=True, padx=(0, 10))

    habit_header = ctk.CTkFrame(habits_container, fg_color=("white", "gray20"))
    habit_header.pack(fill="x", pady=(0, 10))

    ctk.CTkLabel(habit_header, text="My Habits",
                 font=("Roboto", 18, "bold")).pack(side="left", padx=15, pady=15)

    # Scrollable habit list
    habit_frame = ctk.CTkScrollableFrame(habits_container, fg_color=("white", "gray20"))
    habit_frame.pack(fill="both", expand=True)

    # Right column - Controls
    controls_container = ctk.CTkFrame(dashboard, width=250, fg_color="transparent")
    controls_container.pack(side="right", fill="y", padx=(10, 0))
    controls_container.pack_propagate(False)

    # Add habit section
    add_habit_frame = ctk.CTkFrame(controls_container, fg_color=("white", "gray20"), corner_radius=10)
    add_habit_frame.pack(fill="x", pady=(0, 15))

    ctk.CTkLabel(add_habit_frame, text="Add New Habit",
                 font=("Roboto", 16, "bold")).pack(pady=(15, 10), padx=15)

    entry = ctk.CTkEntry(add_habit_frame, height=40, placeholder_text="Enter habit name")
    entry.pack(padx=15, pady=5, fill="x")

    def add_habit():
        name = entry.get().strip()
        if name and name not in habit_data:
            habit_data[name] = {"checked": False, "progress": 0, "created": datetime.now().strftime("%Y-%m-%d")}
            save_habits()
            draw_habits()
            entry.delete(0, "end")

            # Update habit selector
            habit_selector.configure(values=list(habit_data.keys()) or ["No habits"])

            # Show confirmation
            status_label.configure(text=f"Added: {name}", text_color=("#4CAF50", "#81C784"))
            app.after(3000, lambda: status_label.configure(text=""))
        else:
            if not name:
                status_label.configure(text="Please enter a habit name", text_color=("#FF5252", "#FF6B6B"))
            else:
                status_label.configure(text=f"Habit already exists", text_color=("#FF5252", "#FF6B6B"))
            app.after(3000, lambda: status_label.configure(text=""))

    ctk.CTkButton(add_habit_frame, text="Add Habit",
                  font=("Roboto", 14, "bold"),
                  height=35,
                  fg_color=("#3F72AF", "#6998AB"),
                  command=add_habit).pack(padx=15, pady=15, fill="x")

    # Timer section
    timer_frame = ctk.CTkFrame(controls_container, fg_color=("white", "gray20"), corner_radius=10)
    timer_frame.pack(fill="x")

    ctk.CTkLabel(timer_frame, text="Habit Timer",
                 font=("Roboto", 16, "bold")).pack(pady=(15, 10))

    timer_label = ctk.CTkLabel(timer_frame, text="00:00:00",
                               font=("Roboto", 24, "bold"))
    timer_label.pack(pady=5)

    # Habit selection for timer
    habit_selector_frame = ctk.CTkFrame(timer_frame, fg_color="transparent")
    habit_selector_frame.pack(padx=15, pady=5, fill="x")

    ctk.CTkLabel(habit_selector_frame, text="Select habit:",
                 anchor="w", font=("Roboto", 12)).pack(side="left", padx=5)

    habit_selector = ctk.CTkComboBox(timer_frame, values=list(habit_data.keys()) or ["No habits"],
                                     height=35, width=200, font=("Roboto", 12))
    habit_selector.pack(pady=5)

    # Timer inputs
    time_inputs = ctk.CTkFrame(timer_frame, fg_color="transparent")
    time_inputs.pack(pady=10, padx=15)

    timer_h = ctk.CTkEntry(time_inputs, width=60, placeholder_text="HH", justify="center")
    timer_h.pack(side="left", padx=2)

    ctk.CTkLabel(time_inputs, text=":").pack(side="left")

    timer_m = ctk.CTkEntry(time_inputs, width=60, placeholder_text="MM", justify="center")
    timer_m.pack(side="left", padx=2)

    ctk.CTkLabel(time_inputs, text=":").pack(side="left")

    timer_s = ctk.CTkEntry(time_inputs, width=60, placeholder_text="SS", justify="center")
    timer_s.pack(side="left", padx=2)

    # Timer control buttons
    timer_controls = ctk.CTkFrame(timer_frame, fg_color="transparent")
    timer_controls.pack(pady=10, padx=15, fill="x")

    timer_running = [False]
    pause_event = threading.Event()
    pause_event.set()

    def run_timer():
        habit_name = habit_selector.get()
        if habit_name not in habit_data or habit_name == "No habits":
            timer_label.configure(text="Select a valid habit")
            return

        try:
            h = int(timer_h.get()) if timer_h.get() else 0
            m = int(timer_m.get()) if timer_m.get() else 0
            s = int(timer_s.get()) if timer_s.get() else 0
            total_sec = h * 3600 + m * 60 + s

            if total_sec <= 0:
                timer_label.configure(text="Enter a valid time")
                return
        except ValueError:
            timer_label.configure(text="Invalid time format")
            return

        # Disable start button during countdown
        start_btn.configure(state="disabled")
        habit_selector.configure(state="disabled")

        # Update pause button state
        pause_btn.configure(state="normal")

        def countdown():
            nonlocal total_sec
            timer_running[0] = True
            while total_sec > 0 and timer_running[0]:
                pause_event.wait()  # Wait if paused
                mins, secs = divmod(total_sec, 60)
                hrs, mins = divmod(mins, 60)
                timer_label.configure(text=f"{hrs:02}:{mins:02}:{secs:02}")
                time.sleep(1)
                total_sec -= 1

            # When timer completes or is stopped
            if timer_running[0] and total_sec == 0:
                timer_label.configure(text="Completed!")
                habit_data[habit_name]["progress"] = min(100, habit_data[habit_name]["progress"] + 100)
                habit_history.append({
                    "habit": habit_name,
                    "status": "Completed Timer",
                    "time": time.strftime("%Y-%m-%d %H:%M:%S")
                })
                save_habits()
                draw_habits()

                # Reset UI
                app.after(0, lambda: start_btn.configure(state="normal"))
                app.after(0, lambda: habit_selector.configure(state="normal"))
                app.after(0, lambda: pause_btn.configure(state="disabled"))
            else:
                # If timer was stopped
                app.after(0, lambda: timer_label.configure(text="00:00:00"))
                app.after(0, lambda: start_btn.configure(state="normal"))
                app.after(0, lambda: habit_selector.configure(state="normal"))
                app.after(0, lambda: pause_btn.configure(state="disabled"))

        threading.Thread(target=countdown, daemon=True).start()

    def toggle_pause_resume():
        if pause_event.is_set():
            pause_event.clear()
            pause_btn.configure(text="Resume")
        else:
            pause_event.set()
            pause_btn.configure(text="Pause")

    def stop_timer():
        timer_running[0] = False
        pause_event.set()  # Ensure thread isn't blocked
        timer_label.configure(text="00:00:00")
        start_btn.configure(state="normal")
        habit_selector.configure(state="normal")
        pause_btn.configure(state="disabled")

    start_btn = ctk.CTkButton(timer_controls, text="Start",
                              width=80,
                              font=("Roboto", 14),
                              fg_color=("#4CAF50", "#66BB6A"),
                              command=run_timer)
    start_btn.pack(side="left", padx=(0, 5), fill="x", expand=True)

    pause_btn = ctk.CTkButton(timer_controls, text="Pause",
                              width=80,
                              font=("Roboto", 14),
                              fg_color=("#FF9800", "#FFA726"),
                              command=toggle_pause_resume,
                              state="disabled")
    pause_btn.pack(side="left", padx=5, fill="x", expand=True)

    stop_btn = ctk.CTkButton(timer_controls, text="Stop",
                             width=80,
                             font=("Roboto", 14),
                             fg_color=("#F44336", "#EF5350"),
                             command=stop_timer)
    stop_btn.pack(side="left", padx=(5, 0), fill="x", expand=True)

    # Status label for feedback
    status_label = ctk.CTkLabel(controls_container, text="",
                                font=("Roboto", 12))
    status_label.pack(pady=10)

    # Function to draw habit items
    def draw_habits():
        # Clear existing widgets
        for widget in habit_frame.winfo_children():
            widget.destroy()

        if not habit_data:
            empty_label = ctk.CTkLabel(habit_frame,
                                       text="No habits added yet.\nAdd your first habit to get started!",
                                       font=("Roboto", 14))
            empty_label.pack(pady=20)
            return

        # Sort habits by name
        for name in sorted(habit_data.keys()):
            # Container for each habit item
            habit_item = ctk.CTkFrame(habit_frame, fg_color=("gray95", "gray25"), corner_radius=8)
            habit_item.pack(pady=5, padx=10, fill="x")

            # Top row - habit name and check
            top_row = ctk.CTkFrame(habit_item, fg_color="transparent")
            top_row.pack(fill="x", padx=10, pady=(10, 5))

            # Checkbox
            chk_var = tk.BooleanVar(value=habit_data[name]["checked"])

            def on_check(var, habit_name=name):
                habit_data[habit_name]["checked"] = var.get()
                if var.get():
                    # Only add to history if changing from unchecked to checked
                    habit_history.append({
                        "habit": habit_name,
                        "status": "Checked",
                        "time": time.strftime("%Y-%m-%d %H:%M:%S")
                    })
                save_habits()

            chk = ctk.CTkCheckBox(top_row, text="", variable=chk_var,
                                  command=lambda v=chk_var, n=name: on_check(v, n),
                                  width=20, border_width=2)
            chk.pack(side="left")

            # Habit name
            name_label = ctk.CTkLabel(top_row, text=name,
                                      font=("Roboto", 16, "bold"),
                                      anchor="w")
            name_label.pack(side="left", padx=10, fill="x", expand=True)

            # Middle row - progress bar
            middle_row = ctk.CTkFrame(habit_item, fg_color="transparent")
            middle_row.pack(fill="x", padx=10, pady=5)

            progress_text = ctk.CTkLabel(middle_row,
                                         text=f"Progress: {habit_data[name]['progress']}%",
                                         font=("Roboto", 12))
            progress_text.pack(side="left", pady=5)

            # Progress bar
            prog = ctk.CTkProgressBar(habit_item, width=200)
            prog.set(habit_data[name]["progress"] / 100)
            prog.pack(padx=10, pady=(0, 5), fill="x")

            # Button row
            button_row = ctk.CTkFrame(habit_item, fg_color="transparent")
            button_row.pack(fill="x", padx=10, pady=(5, 10))

            def mark_done(habit_name=name):
                habit_data[habit_name]["progress"] = 100
                habit_data[habit_name]["checked"] = True
                habit_history.append({
                    "habit": habit_name,
                    "status": "Completed",
                    "time": time.strftime("%Y-%m-%d %H:%M:%S")
                })
                save_habits()
                draw_habits()

                # Update status
                status_label.configure(
                    text=f"'{habit_name}' marked as complete!",
                    text_color=("#4CAF50", "#81C784")
                )
                app.after(3000, lambda: status_label.configure(text=""))

            def delete_habit(habit_name=name):
                confirm = ctk.CTkToplevel(app)
                confirm.title("Confirm Delete")
                confirm.geometry("300x150")
                confirm.transient(app)
                confirm.grab_set()

                ctk.CTkLabel(confirm, text=f"Delete '{habit_name}'?",
                             font=("Roboto", 16, "bold")).pack(pady=(20, 10))

                buttons = ctk.CTkFrame(confirm, fg_color="transparent")
                buttons.pack(pady=10)

                def confirm_delete():
                    del habit_data[habit_name]
                    save_habits()
                    draw_habits()
                    confirm.destroy()

                    # Update habit selector
                    habit_selector.configure(values=list(habit_data.keys()) or ["No habits"])

                    # Show confirmation
                    status_label.configure(
                        text=f"'{habit_name}' deleted",
                        text_color=("#F44336", "#EF5350")
                    )
                    app.after(3000, lambda: status_label.configure(text=""))

                ctk.CTkButton(buttons, text="Cancel", width=100,
                              command=confirm.destroy).pack(side="left", padx=10)

                ctk.CTkButton(buttons, text="Delete", width=100,
                              fg_color="#F44336",
                              command=confirm_delete).pack(side="left", padx=10)

            # Buttons with icons
            done_btn = ctk.CTkButton(button_row, text="✓ Complete",
                                     font=("Roboto", 12),
                                     fg_color=("#4CAF50", "#66BB6A"),  # Green
                                     width=30, height=30,
                                     command=lambda n=name: mark_done(n))
            done_btn.pack(side="left", padx=(0, 5))

            # Spacer to push delete button to right
            spacer = ctk.CTkFrame(button_row, fg_color="transparent")
            spacer.pack(side="left", fill="x", expand=True)

            del_btn = ctk.CTkButton(button_row, text="🗑️ Delete",
                                    font=("Roboto", 12),
                                    fg_color=("#F44336", "#EF5350"),  # Red
                                    width=30, height=30,
                                    command=lambda n=name: delete_habit(n))
            del_btn.pack(side="right")

    # Draw habits initially
    draw_habits()

    # Add print button to dashboard
    print_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
    print_frame.pack(pady=10, padx=20, fill="x")

    def generate_printable_report():

        # Create a filename for the PDF
        filename = f"{current_user}_habit_report.pdf"
        doc = SimpleDocTemplate(filename, pagesize=letter)

        # Container for the 'Flowable' objects
        elements = []

        # Define styles
        styles = getSampleStyleSheet()
        title_style = styles['Title']
        heading_style = styles['Heading2']
        normal_style = styles['Normal']

        # Custom styles
        date_style = ParagraphStyle(
            'DateStyle',
            parent=normal_style,
            textColor=colors.gray,
            fontSize=10
        )

        habit_name_style = ParagraphStyle(
            'HabitName',
            parent=normal_style,
            fontSize=14,
            fontName='Helvetica-Bold'
        )

        status_style = ParagraphStyle(
            'Status',
            parent=normal_style,
            fontSize=10,
            fontName='Helvetica-Oblique',
            textColor=colors.darkgrey
        )

        status_completed_style = ParagraphStyle(
            'StatusCompleted',
            parent=status_style,
            textColor=colors.green
        )

        # Add title and date
        elements.append(Paragraph(f"Habit Report for {current_user}", title_style))
        elements.append(Paragraph(f"Generated on {datetime.now().strftime('%B %d, %Y at %H:%M')}", date_style))
        elements.append(Spacer(1, 0.25 * inch))

        # Add current habits section
        elements.append(Paragraph("Current Habits", heading_style))
        elements.append(Spacer(1, 0.1 * inch))

        if not habit_data:
            elements.append(Paragraph("No habits added yet.", normal_style))
        else:
            # For each habit, create a table with habit details
            for name, details in habit_data.items():
                status = "Completed" if details["checked"] else "In Progress"
                status_style_to_use = status_completed_style if details["checked"] else status_style

                # Create a simple progress bar as a table
                progress_bar_data = [['']]
                progress_bar = Table(progress_bar_data, colWidths=[5 * inch])
                progress_bar.setStyle(TableStyle([
                    ('BACKGROUND', (0, 0), (0, 0), colors.lightgrey),
                    ('LINEBELOW', (0, 0), (0, 0), 1, colors.grey),
                    ('ROUNDEDCORNERS', [5, 5, 5, 5]),
                ]))

                # Create a colored cell for the progress
                progress_width = (details['progress'] / 100) * 5 * inch
                if progress_width > 0:
                    progress_cell = Table([['']], colWidths=[progress_width])
                    progress_cell.setStyle(TableStyle([
                        ('BACKGROUND', (0, 0), (0, 0), colors.blue),
                        ('ROUNDEDCORNERS', [5, 5, 5, 5]),
                    ]))

                # Habit content
                habit_content = [
                    [Paragraph(name, habit_name_style)],
                    [Paragraph(f"Created: {details.get('created', 'Unknown')}", date_style)],
                ]

                if progress_width > 0:
                    habit_content.append([progress_cell])
                habit_content.append([progress_bar])
                habit_content.append(
                    [Paragraph(f"Status: {status} - {details['progress']}% complete", status_style_to_use)])

                habit_table = Table(habit_content, colWidths=[5.5 * inch])
                habit_table.setStyle(TableStyle([
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('TOPPADDING', (0, 0), (-1, -1), 5),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                    ('BOX', (0, 0), (-1, -1), 1, colors.lightgrey),
                    ('BACKGROUND', (0, 0), (-1, -1), colors.whitesmoke),
                    ('ROUNDEDCORNERS', [5, 5, 5, 5]),
                ]))

                elements.append(habit_table)
                elements.append(Spacer(1, 0.2 * inch))

        # Add scheduled habits if any
        if data.get("scheduler"):
            elements.append(Spacer(1, 0.1 * inch))
            elements.append(Paragraph("Scheduled Habits", heading_style))
            elements.append(Spacer(1, 0.1 * inch))

            # Create table for scheduled habits
            schedule_data = [["Date", "Time", "Habit"]]

            all_scheduled = []
            for habit_name, schedules in data.get("scheduler", {}).items():
                for schedule in schedules:
                    all_scheduled.append({
                        "habit": habit_name,
                        "date": schedule["date"],
                        "time": schedule["time"]
                    })

            # Sort by date and time
            all_scheduled.sort(key=lambda x: (x["date"], x["time"]))

            for schedule in all_scheduled:
                schedule_data.append([
                    schedule['date'],
                    schedule['time'],
                    schedule['habit']
                ])

            schedule_table = Table(schedule_data, colWidths=[1.5 * inch, 1.5 * inch, 3 * inch])
            schedule_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                ('GRID', (0, 0), (-1, -1), 1, colors.lightgrey),
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ]))

            elements.append(schedule_table)

        # Add recent history
        if habit_history:
            elements.append(Spacer(1, 0.2 * inch))
            elements.append(Paragraph("Recent History", heading_style))
            elements.append(Spacer(1, 0.1 * inch))

            history_data = []
            for record in habit_history[-10:]:  # Show only last 10 records
                history_data.append([
                    record['time'],
                    record['habit'],
                    record['status']
                ])

            if history_data:
                history_table = Table(history_data, colWidths=[1.5 * inch, 2.5 * inch, 2 * inch])
                history_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Oblique'),
                    ('TEXTCOLOR', (0, 0), (0, -1), colors.grey),
                    ('FONTNAME', (1, 0), (1, -1), 'Helvetica-Bold'),
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.lightgrey),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ]))

                elements.append(history_table)

        # Add footer
        elements.append(Spacer(1, 0.5 * inch))
        elements.append(Paragraph("Habit Master - Track your habits and improve your life", normal_style))

        # Build the PDF
        doc.build(elements)

        # Open the PDF
        try:
            import webbrowser
            webbrowser.open('file://' + os.path.realpath(filename))
        except:
            # If opening fails, just inform the user where the file is saved
            print(f"PDF report saved as {os.path.realpath(filename)}")

    # Update the button in the CTk interface
    ctk.CTkButton(print_frame, text="Generate PDF Report",
                  font=("Roboto", 14),
                  height=35,
                  fg_color="#4CAF50",
                  command=generate_printable_report).pack(side="left", padx=20)
    # Updates the daily reminder system
    def check_scheduler():
        current_time = datetime.now()
        current_date = current_time.strftime("%Y-%m-%d")
        current_hour_minute = current_time.strftime("%H:%M")

        # Check if there are any scheduled habits for the current time
        for habit_name, schedules in data.get("scheduler", {}).items():
            for schedule in schedules:
                if current_date == schedule["date"] and current_hour_minute == schedule["time"]:
                    # Show notification
                    notification = ctk.CTkToplevel(app)
                    notification.title("Habit Reminder")
                    notification.geometry("400x200")
                    notification.attributes('-topmost', True)

                    ctk.CTkLabel(notification, text="Habit Reminder",
                                 font=("Roboto", 20, "bold")).pack(pady=(20, 10))

                    ctk.CTkLabel(notification, text=f"Time to complete your habit:",
                                 font=("Roboto", 14)).pack(pady=5)

                    ctk.CTkLabel(notification, text=habit_name,
                                 font=("Roboto", 16, "bold"),
                                 text_color="#3F72AF").pack(pady=5)

                    ctk.CTkButton(notification, text="Dismiss",
                                  font=("Roboto", 14),
                                  command=notification.destroy).pack(pady=15)

        # Schedule the next check in 1 minute
        app.after(60000, check_scheduler)

    # Initialize scheduler check
    app.after(1000, check_scheduler)

    # Start the main loop
    app.mainloop()

if __name__ == "__main__":
    show_login()
